%% PID Tuner (Grid Search Method)
clear all; close all;
warning off

Ts = 0.1; % 10 Hz
omega_min = 0.01; % Low enough for integrator behavior
omega_max = pi / Ts * 0.95; % ~95% of Nyquist to avoid aliasing

% Stability margins
Gm_des = 8; % Desired gain margin
Pm_des = 45; % Desired phase margin

% Gain variations
Kps = linspace(0.6, 1.2, 10);
Kis = linspace(0.05, 0.2, 10);
Kds = linspace(0.7, 1.2, 10); 

% LPF factor
Kf = 1e5;

OPEN_LOOP_SYSTEMS = cell(1,length(Kps)*length(Kis)*length(Kds));
figure;
for i=0:3
timedelay = i;
w = [.1 .2 .2 .25 .25]; % Order of weights: bandwidth, overshoot, settling time, gain margin, phase margin
tuner_data = struct();
% Loop and collect all variants
count = 1;
for Kp = Kps
    for Ki = Kis
        for Kd = Kds
            % GAINS{end+1} = [Kp Ki Kd];
            P = tf(Kp,1,Ts);
            I = c2d(tf(Ki,[1 0]),Ts,'zoh');
            D = c2d(tf([Kd 0],[1 Kf]),Ts,'zoh');
            PID = P + I + D;
            RATE = c2d(tf(1,[1 Kd 0]),Ts,'zoh');
            OPEN_LOOP_SYSTEM = PID*RATE;
            OPEN_LOOP_SYSTEM.InputDelay = timedelay;
            OPEN_LOOP_SYSTEMS{count} = OPEN_LOOP_SYSTEM;
            % Compute Stability Margins
            [Gm,Pm,Wcg,Wcp] = margin(OPEN_LOOP_SYSTEM);
            % margins = [margins; Gm Pm];
            % Collect step response characteristics
            stepprops = stepinfo(feedback(OPEN_LOOP_SYSTEM,1,-1));
            overshoot = stepprops.Overshoot;
            settlingtime = stepprops.SettlingTime;
            % Compute bandwidths 
            [mag,phase,wout] = nichols(OPEN_LOOP_SYSTEM);
            mag = squeeze(mag); phase = squeeze(phase); wout = squeeze(wout);
            mag = mag2db(mag);
            woutf = omega_min:.01:omega_max; woutf = woutf';
            magf = interp1(wout,mag,woutf);
            ind = interp1(magf,1:length(magf),-3,'nearest');
            bandwidth = woutf(ind);      
            % Compute costs
            if Gm < Gm_des
                Gm = inf;
            end
            if Pm < Pm_des
                Pm = inf;
            end
            cost = dot(w,[1/bandwidth overshoot settlingtime Gm Pm]);
            % Store in structure 
            tuner_data(count).cost = cost;
            tuner_data(count).gains = [Kp Ki Kd];
            tuner_data(count).overshoot = overshoot;
            tuner_data(count).settlingtime = settlingtime;
            tuner_data(count).bandwidth = bandwidth;
            tuner_data(count).gainmargin = Gm;
            tuner_data(count).phasemargin = Pm;
            count = count + 1;
        end
    end
end

% Find min cost gains
[minCost, minIndex] = min([tuner_data.cost]);
optimalGains = tuner_data(minIndex).gains;

% Display results for the optimal gains
tuner_data(minIndex).gainmargin
tuner_data(minIndex).phasemargin
tuner_data(minIndex).bandwidth
tuner_data(minIndex).overshoot
tuner_data(minIndex).settlingtime
step(feedback(OPEN_LOOP_SYSTEMS{minIndex},1))
% nichols(OPEN_LOOP_SYSTEMS{minIndex})

% Find max cost gains
[maxCost, maxIndex] = max([tuner_data.cost]);
worstGains = tuner_data(maxIndex).gains;

% % Display results for the worst gains
% tuner_data(maxIndex).gainmargin
% tuner_data(maxIndex).phasemargin
% tuner_data(maxIndex).bandwidth
% tuner_data(maxIndex).overshoot
% tuner_data(maxIndex).settlingtime
% step(feedback(OPEN_LOOP_SYSTEMS{maxIndex},1))
% nichols(OPEN_LOOP_SYSTEMS{maxIndex})